/********************************************************************************
* CompositeKey.cs                                                               *
*                                                                               *
* Author: Denes Solti                                                           *
********************************************************************************/
using System;
using System.Diagnostics.CodeAnalysis;

using static System.StringComparer;

namespace Solti.Utils.DI.Internals
{
    /// <summary>
    /// Represents a composite key, used in internal lookups.
    /// </summary>
    /// <remarks>This is an internal class not meant for direct use.</remarks>
    [SuppressMessage("Design", "CA1036:Override methods on comparable types")]
    public sealed class CompositeKey: IComparable<CompositeKey>, IEquatable<CompositeKey>  // Must be public in order to let us use in codes generated by CompiledCodeBTreeLookup
    {
        private readonly long FHandle;

        private readonly string? FName;

        /// <summary>
        /// Creates a new <see cref="CompositeKey"/> instance.
        /// </summary>
        public CompositeKey(Type iface, string? name)
        {
            FHandle = (long) iface.TypeHandle.Value;
            FName = name;   
        }

        /// <inheritdoc/>
        public override int GetHashCode() =>
            #pragma warning disable CA1307
            unchecked(FHandle.GetHashCode() ^ (FName?.GetHashCode() ?? 0));
            #pragma warning restore CA1307

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is CompositeKey other && Equals(other);

        /// <summary>
        /// See <see cref="IEquatable{T}.Equals(T)"/>
        /// </summary>
        public bool Equals(CompositeKey other) => FHandle == other.FHandle && FName == other.FName;

        /// <summary>
        /// See <see cref="IComparable{T}.CompareTo(T)"/>
        /// </summary>
        public int CompareTo(CompositeKey other)
        {
            //
            // We have to return Int32 -> Math.Sign()
            //

            int order = Math.Sign(FHandle - other.FHandle);
            if (order is 0)
                //
                // StringComparer supports NULL despite it is not reflected by nullable annotation
                //

                order = InvariantCultureIgnoreCase.Compare(FName, other.FName);
            return order;
        }
    }
}
